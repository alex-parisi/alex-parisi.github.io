<!doctype html>
<html lang="en" data-bs-theme="auto">
<head>
    <title>Parisipedia</title>
    <script src="../js/color-modes.js"></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="Alex Parisi">
    <link rel="canonical" href="https://getbootstrap.com/docs/5.3/examples/blog/">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        .bd-placeholder-img {
            font-size: 1.125rem;
            text-anchor: middle;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }

        @media (min-width: 768px) {
            .bd-placeholder-img-lg {
                font-size: 3.5rem;
            }
        }

        .b-example-divider {
            width: 100%;
            height: 3rem;
            background-color: rgba(0, 0, 0, .1);
            border: solid rgba(0, 0, 0, .15);
            border-width: 1px 0;
            box-shadow: inset 0 .5em 1.5em rgba(0, 0, 0, .1), inset 0 .125em .5em rgba(0, 0, 0, .15);
        }

        .b-example-vr {
            flex-shrink: 0;
            width: 1.5rem;
            height: 100vh;
        }

        .bi {
            vertical-align: -.125em;
            fill: currentColor;
        }

        .nav-scroller {
            position: relative;
            z-index: 2;
            height: 2.75rem;
            overflow-y: hidden;
        }

        .nav-scroller .nav {
            display: flex;
            flex-wrap: nowrap;
            padding-bottom: 1rem;
            margin-top: -1px;
            overflow-x: auto;
            text-align: center;
            white-space: nowrap;
            -webkit-overflow-scrolling: touch;
        }

        .btn-bd-primary {
            --bd-violet-bg: #712cf9;
            --bd-violet-rgb: 112.520718, 44.062154, 249.437846;
            --bs-btn-font-weight: 600;
            --bs-btn-color: var(--bs-white);
            --bs-btn-bg: var(--bd-violet-bg);
            --bs-btn-border-color: var(--bd-violet-bg);
            --bs-btn-hover-color: var(--bs-white);
            --bs-btn-hover-bg: #6528e0;
            --bs-btn-hover-border-color: #6528e0;
            --bs-btn-focus-shadow-rgb: var(--bd-violet-rgb);
            --bs-btn-active-color: var(--bs-btn-hover-color);
            --bs-btn-active-bg: #5a23c8;
            --bs-btn-active-border-color: #5a23c8;
        }

        .bd-mode-toggle {
            z-index: 1500;
        }

        .bd-mode-toggle .dropdown-menu .active .bi {
            display: block !important;
        }

        .reveal pre code, .hljs {
            background-color: #C1C1C1 !important;
        }

        .reveal pre, .hljs {
            box-shadow: none !important;
        }
    </style>
    <link href="https://fonts.googleapis.com/css?family=Playfair&#43;Display:700,900&amp;display=swap" rel="stylesheet">
    <link href="../css/blog.css" rel="stylesheet">
</head>
<body>
<svg xmlns="http://www.w3.org/2000/svg" class="d-none">
    <symbol id="check2" viewBox="0 0 16 16">
        <path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/>
    </symbol>
    <symbol id="circle-half" viewBox="0 0 16 16">
        <path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"/>
    </symbol>
    <symbol id="moon-stars-fill" viewBox="0 0 16 16">
        <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
        <path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/>
    </symbol>
    <symbol id="sun-fill" viewBox="0 0 16 16">
        <path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
    </symbol>
</svg>
<div class="dropdown position-fixed bottom-0 end-0 mb-3 me-3 bd-mode-toggle">
    <button class="btn btn-bd-primary py-2 dropdown-toggle d-flex align-items-center"
            id="bd-theme"
            type="button"
            aria-expanded="false"
            data-bs-toggle="dropdown"
            aria-label="Toggle theme (auto)">
        <svg class="bi my-1 theme-icon-active" width="1em" height="1em">
            <use href="#circle-half"></use>
        </svg>
        <span class="visually-hidden" id="bd-theme-text">Toggle theme</span>
    </button>
    <ul class="dropdown-menu dropdown-menu-end shadow" aria-labelledby="bd-theme-text">
        <li>
            <button type="button" class="dropdown-item d-flex align-items-center" data-bs-theme-value="light"
                    aria-pressed="false">
                <svg class="bi me-2 opacity-50" width="1em" height="1em">
                    <use href="#sun-fill"></use>
                </svg>
                Light
                <svg class="bi ms-auto d-none" width="1em" height="1em">
                    <use href="#check2"></use>
                </svg>
            </button>
        </li>
        <li>
            <button type="button" class="dropdown-item d-flex align-items-center" data-bs-theme-value="dark"
                    aria-pressed="false">
                <svg class="bi me-2 opacity-50" width="1em" height="1em">
                    <use href="#moon-stars-fill"></use>
                </svg>
                Dark
                <svg class="bi ms-auto d-none" width="1em" height="1em">
                    <use href="#check2"></use>
                </svg>
            </button>
        </li>
        <li>
            <button type="button" class="dropdown-item d-flex align-items-center active" data-bs-theme-value="auto"
                    aria-pressed="true">
                <svg class="bi me-2 opacity-50" width="1em" height="1em">
                    <use href="#circle-half"></use>
                </svg>
                Auto
                <svg class="bi ms-auto d-none" width="1em" height="1em">
                    <use href="#check2"></use>
                </svg>
            </button>
        </li>
    </ul>
</div>
<svg xmlns="http://www.w3.org/2000/svg" class="d-none">
    <symbol id="aperture" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
            stroke-width="2" viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="10"/>
        <path d="M14.31 8l5.74 9.94M9.69 8h11.48M7.38 12l5.74-9.94M9.69 16L3.95 6.06M14.31 16H2.83m13.79-4l-5.74 9.94"/>
    </symbol>
    <symbol id="cart" viewBox="0 0 16 16">
        <path d="M0 1.5A.5.5 0 0 1 .5 1H2a.5.5 0 0 1 .485.379L2.89 3H14.5a.5.5 0 0 1 .49.598l-1 5a.5.5 0 0 1-.465.401l-9.397.472L4.415 11H13a.5.5 0 0 1 0 1H4a.5.5 0 0 1-.491-.408L2.01 3.607 1.61 2H.5a.5.5 0 0 1-.5-.5zM3.102 4l.84 4.479 9.144-.459L13.89 4H3.102zM5 12a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm7 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm-7 1a1 1 0 1 1 0 2 1 1 0 0 1 0-2zm7 0a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/>
    </symbol>
    <symbol id="chevron-right" viewBox="0 0 16 16">
        <path fill-rule="evenodd"
              d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </symbol>
</svg>
<div class="container">
    <div class="nav-scroller py-1 mb-3 border-bottom">
        <nav class="nav nav-underline justify-content-between">
            <a class="nav-item nav-link link-body-emphasis" href="javascript:history.back()">Back</a>
            <a class="nav-item nav-link link-body-emphasis" href="wiki.html">Wiki Home</a>
            <a class="nav-item nav-link link-body-emphasis" href="../index.html">Main Home</a>
        </nav>
    </div>
</div>

<main class="container">
    <div class="row g-5">
        <div class="col-md-8 p-4">
            <h1>Circular/Ring Buffers</h1>
            <hr>
            <h3>Brief:</h3>
            <br>
            <ul>
                <li>A <b>circular buffer</b> (also known as a <b>ring buffer</b>) is a fixed-size data structure that uses a
                    single, contiguous block of memory as if it were connected end-to-end. It maintains two pointers: a <b>write
                        pointer</b>(where new data is added) and a <b>read pointer</b> (where data is consumed). When either
                    pointer reaches the end of the buffer, it wraps around to the beginning.</li>
                <li>Since it uses a fixed-size buffer, there is no need to allocate or free memory dynamically. This helps
                    avoid memory fragmentation and keeps performance consistent.</li>
                <li>As the buffer fills up, new audio samples can overwrite the oldest samples, which is
                    ideal for real-time audio where recent data is often more relevant.</li>
                <li>Circular buffers are perfect for scenarios where one part of the system produces data
                    while another part consumes it. The circular nature ensures smooth
                    data flow, even if the producer and consumer operate at slightly different speeds.</li>
            </ul>
            <hr>
            <h3>Considerations:</h3>
            <br>
            <ul>
                <li>The <b>producer</b> and <b>consumer</b> are typically on different threads, and therefore read and writing to the buffer is thread-safe.</li>
                <li>A mutex can be utilized to protect the buffer from being concurrently modified.</li>
                <li>A condition variable can be utilized by a producer to notify a waiting consumer.</li>
            </ul>
            <hr>
            <h3>C++ Implementation</h3>
            <br>
            <pre><code>/// CircularBuffer.h

/**
Copyright © 2025 Alex Parisi

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef CIRCULAR_BUFFER_H
#define CIRCULAR_BUFFER_H

#include &lt;array&gt;
#include &lt;atomic&gt;
#include &lt;mutex&gt;
#include &lt;optional&gt;
#include &lt;vector&gt;

/**
 * @brief A thread-safe circular buffer with a fixed size that supports
 * concurrent push and pop operations. Thread-safety is achieved by using a
 * mutex and condition variable. The producer (writing thread) will never be
 * blocked, as the buffer will overwrite the oldest data if it is full. The
 * consumer (reading thread) will wait for data if the buffer is empty, or does
 * not contain enough requested samples.
 * @tparam T the type of elements in the buffer
 * @tparam blockSize the blockSize for array operations. If this is not defined,
 * you can only use std::vector for block operations.
 */
template&lt;typename T, size_t blockSize = 0&gt;
class CircularBuffer {
public:
    explicit CircularBuffer(const size_t capacity) : m_capacity(capacity) {
        m_buffer.resize(capacity);
    }

    /**
     * @brief Push a sample into the buffer
     * @param value The sample to push
     */
    auto push(const T &value) -&gt; void {
        std::unique_lock lock(m_mutex);
        _push(value);
        m_cv.notify_one();
    }

    /**
     * @brief Push multiple samples into the buffer
     * @param values Pointer to the array of samples
     * @param count Number of samples to push
     */
    auto push(const T *values, const size_t count) -&gt; void {
        if (values == nullptr)
            return;
        std::unique_lock lock(m_mutex);
        for (size_t i = 0; i &lt; count; ++i) {
            _push(values[i]);
        }
        m_cv.notify_one();
    }

    /**
     * @brief Push a vector of samples into the buffer
     * @param values The vector of samples to push
     */
    auto push(const std::vector&lt;T&gt; &values) -&gt; void {
        if (values.empty())
            return;
        std::unique_lock lock(m_mutex);
        for (const auto &value: values) {
            _push(value);
        }
        m_cv.notify_one();
    }

    /**
     * @brief Push an array of samples into the buffer. Requires the blockSize
     * to be defined when templating.
     * @param values The array of samples to push
     */
    auto push(const std::array&lt;T, blockSize&gt; &values) -&gt; void {
        if (blockSize &lt;= 0) {
            return;
        }
        std::unique_lock lock(m_mutex);
        for (size_t i = 0; i &lt; blockSize; ++i) {
            _push(values[i]);
        }
        m_cv.notify_one();
    }

    /**
     * @brief Pop a sample from the buffer
     * @return The sample that was popped
     */
    auto pop() -&gt; T {
        std::unique_lock lock(m_mutex);
        /// Wait until there's at least one sample
        m_cv.wait(lock, [this]() -&gt; bool { return m_size &gt; 0; });
        return _pop();
    }

    /**
     * @brief Pop samples from the buffer directly into an array or pointer.
     * @param values Pointer to the array to store the samples
     * @param count The number of samples to pop
     * @return
     */
    auto pop(T *values, const size_t count) {
        if (count &lt;= 0) {
            return;
        }
        std::unique_lock lock(m_mutex);
        /// Wait until there's enough samples
        m_cv.wait(lock, [this, count]() -&gt; bool { return m_size &gt;= count; });
        for (size_t i = 0; i &lt; count; ++i) {
            values[i] = _pop();
        }
    }

    /**
     * @brief Pop multiple samples from the buffer
     * @param count The number of samples to pop
     * @return A vector of samples that were popped
     */
    auto pop(const size_t count) -&gt; std::vector&lt;T&gt; {
        if (count &lt;= 0)
            return {};
        std::unique_lock lock(m_mutex);
        /// Wait until there's enough samples
        m_cv.wait(lock, [this, count]() -&gt; bool { return m_size &gt;= count; });
        std::vector&lt;T&gt; values(count);
        for (size_t i = 0; i &lt; count; ++i) {
            values[i] = _pop();
        }
        return values;
    }

    /**
     * @brief Pop a block of samples from the buffer. Requires the blockSize to
     * be defined when templating.
     * @return An array of samples that were popped
     */
    auto pop_block() -&gt; std::array&lt;T, blockSize&gt; {
        if (blockSize &lt;= 0) {
            return {};
        }
        std::unique_lock lock(m_mutex);
        /// Wait until there's enough samples
        m_cv.wait(lock, [this]() -&gt; bool { return m_size &gt;= blockSize; });
        std::array&lt;T, blockSize&gt; values;
        for (size_t i = 0; i &lt; blockSize; ++i) {
            values[i] = _pop();
        }
        return values;
    }

    /**
     * @brief Clears the buffer
     */
    auto clear() -&gt; void {
        std::unique_lock lock(m_mutex);
        m_head = 0;
        m_tail = 0;
        m_size = 0;
        m_buffer.clear();
        m_buffer.resize(m_capacity);
    }

    /**
     * @brief Get the size of the buffer
     * @return The number of samples currently stored in the buffer
     */
    [[nodiscard]] auto size() -&gt; size_t { return m_size; }

    /**
     * @brief Check if the buffer is empty
     * @return True if the buffer is empty, false otherwise
     */
    [[nodiscard]] auto empty() const -&gt; bool { return m_size == 0; }

    /**
     * @brief Check if the buffer is full
     * @return True if the buffer is full, false otherwise
     */
    [[nodiscard]] auto full() const -&gt; bool { return m_size == m_capacity; }

    /**
     * @brief Get the capacity of the buffer
     * @return The maximum number of samples the buffer can hold
     */
    [[nodiscard]] auto capacity() const -&gt; size_t { return m_capacity; }

private:
    /**
     * @brief Helper function to push a value into the buffer
     * @param value The value to push
     */
    auto _push(const T &value) -&gt; void {
        m_buffer[m_head] = value;
        m_head = (m_head + 1) % m_capacity;
        /// Update the current size, ensuring it doesn't exceed the buffer size
        /// if we've overwritten old data. If our buffer is full, make sure the
        /// head and tail pointers are the same.
        m_size = std::min(m_size + 1, m_capacity);
        if (m_size == m_capacity) {
            m_tail = m_head;
        }
    }

    /**
     * @brief Helper function to pop a value from the buffer
     * @return The value that was popped
     */
    auto _pop() -&gt; T {
        T value = std::move(m_buffer[m_tail].value());
        m_buffer[m_tail].reset();
        m_tail = (m_tail + 1) % m_capacity;
        --m_size;
        return value;
    }

    /** The buffer */
    std::vector&lt;std::optional&lt;T&gt;&gt; m_buffer;

    /** The head of the buffer */
    size_t m_head = 0;

    /** The tail of the buffer */
    size_t m_tail = 0;

    /** The number of samples currently stored in the buffer */
    std::atomic&lt;size_t&gt; m_size = 0;

    /** The maximum number of samples the buffer can hold */
    size_t m_capacity = 0;

    /** The mutex used to protect the buffer */
    std::mutex m_mutex;

    /** The condition variable used to notify waiting consumer threads */
    std::condition_variable m_cv;
};

#endif // CIRCULAR_BUFFER_H</code></pre>
            <hr>
            <h3>Notes:</h3>
            <br>
            <ul>
                <li><code>m_size</code> is an atomic to allow for some of the house-keeping functions like <code>size()</code> and <code>empty()</code> to not require locking the mutex.</li>
                <li>The class is templated with the type of the object stored in the buffer and the buffer size for block operations: <pre><code>/// Block size = 512, Total buffer size = 2048
CircularBuffer&lt;float, 512&gt; buffer(2048);

/// Buffer gets filled with data

std::array&lt;float, 512&gt; block = buffer.pop_block();</code></pre></li>
                <li>If the block size is not provided, the only supported block operations involve raw pointers and heap-allocated containers like <code>std::vector</code>:<pre><code>/// Block size = 0, Total buffer size = 512
CircularBuffer&lt;double&gt; buffer(512);

/// Buffer gets filled with data

auto block = buffer.pop_block(); /// block == {}

std::vector&lt;double&gt; block = buffer.pop(10); /// block.size() == 10

int size = 10;
double* array[size];
buffer.pop(array, size); /// array now contains the popped data</code></pre></li>
                <li>The buffer utilizes std::optional to allow for proper resetting of the object state after moving, which is useful when <code>T</code> is templated to be a complex class.</li>
                <li>Data is moved from the buffer to the consumer, avoiding copies.</li>
            </ul>
        </div>

        <div class="col-md-4">
            <div class="position-sticky" style="top: 2rem;">
                <div class="p-4 mb-3 bg-body-tertiary rounded">
                    <h4 class="fst-italic">Table Of Contents</h4>
                    <h5>Audio Topics</h5>
                    <ul>
                        <li><a href="#"><b>Circular Buffers</b></a></li>
                        <li><a href="digitalBiquadFilter.html">Digital Biquad Filters</a></li>
                        <ul>
                            <li><a href="lowPassFilter.html">Low Pass</a></li>
                            <li><a href="highPassFilter.html">High Pass</a></li>
                            <li><a href="bandPassFilter.html">Band Pass</a></li>
                            <li><a href="notchFilter.html">Notch</a></li>
                            <li><a href="allPassFilter.html">All Pass</a></li>
                            <li><a href="peakingEQFilter.html">Peaking EQ</a></li>
                        </ul>
                    </ul>
                    <h5>C++ Topics</h5>
                    <ul>
                        <li><a href="concepts.html">Concepts (C++20)</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</main>

<footer class="py-5 text-center text-body-secondary bg-body-tertiary">
    <p>© 2025 Alex Parisi</p>
    <p class="mb-0">
        <a href="#">Back to top</a>
    </p>
</footer>
<script src="../js/bootstrap.bundle.min.js"></script>

</body>
</html>
